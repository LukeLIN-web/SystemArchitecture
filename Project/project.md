As you can notice, there were 75 extra bonus points due to the complexity of the project and the lack of time issue considerations. Based on our conversation, you have also been assigned 5 points for fairly grading your work compared to the other students who will be submitting two days later.

| General architectural features                               | 32 instructions implementation (in any way)                  | Done at the control level with the available "primitives (even though magical)" | 5    | 5    |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---- | ---- |
| Instructions respect 32 bits and divided as required (5b opcode, 5bx3 regs, 12b literals) | Done                                                         | 5                                                            | 5    |      |
| BONUS: Arith. ops. are signed 64b in little-endian and float. ops. are double precision (no magic) | Missed                                                       | 0                                                            | 7    |      |
| BONUS: Implementation of the macro instructions without magic | Missed                                                       | 0                                                            | 3    |      |
| 32 GP registers R0-31                                        | Done                                                         | 5                                                            | 5    |      |
| Registers are 64b, R31 is stack point., and no state flags   | There are 33 registers in the regfile with the last one having "magic guard number" which is in some ways used as a correctness guard, if seen as software simulator, or a state flag, if seen as a hardware component (which implies huge changes to the logic). The stack pointer is implemented and the registers are all 64b. | 3                                                            | 5    |      |
| BONUS: Sanity checks                                         | Only implemented with the Caster and the SRAM using assertion. Typing was verified using the C++ standards via entanglement to shared pointers. Many other functionalities are not checked, though. | 6                                                            | 10   |      |
| HW devices implementation                                    | HW components (devices)                                      | All implemented except Add4, Control Array, Demux, Multi-ported RegFile, and Two's Complement. The Reg and RegFile implementations are also not neat. | 5    | 7    |
| HW implementation without magic                              | A lot of magic happened, it is just C++ implemented          | 0                                                            | 6    |      |
| Having a proper structure for interacting with the rest of the processor | Done clearly                                                 | 5                                                            | 5    |      |
| Construct instruction data-paths                             | Done                                                         | 5                                                            | 5    |      |
| Simulation and execution                                     | Having a simulator                                           | The tests were used for simulating the execution of multiple parts of the processor in a fair way to some extent to show it can handle the execution of a sequence of instructions. | 10   | 12   |
| Pipelined execution                                          | none-pipelined processor so it is missed.                    | 0                                                            | 5    |      |
| BONUS: Having the simulator automated                        | There is no way to input what mimics a memory with stored instructions and have the execution automated from so. | 0                                                            | 10   |      |
| Instruction fetch and decode                                 | Fetching instructions and controlling the processor for execution | Done                                                         | 10   | 10   |
| BONUS: Inst-Level Parallelism concretisation (with scheduling etc..) | none-pipelined processor so it is missed.                    | 0                                                            | 15   |      |
| Checking hazards                                             | none-pipelined processor so it is missed.                    | 0                                                            | 10   |      |
| BONUS: Checking hazards without magic                        | Missed                                                       | 0                                                            | 10   |      |
| BONUS: Multi-issue Out-Of-Order                              | Missed                                                       | 0                                                            | 15   |      |
| Microarchitectural implementation                            | Controlled and synchronous design                            | Done                                                         | 5    | 5    |
| A proper modularity and way of testing components            | Tests are provided but very hard to decipher how to use them without any documentation. The code should be inspected for so. | 8                                                            | 10   |      |
| Construct and provide the architecture of the processor      | The architecture is built based on 5 stages (fetch, decode, execute, L/S, writeback) but constructed in a way that allows the simulation to happen more than how it should have been wired logically/structurally. | 3                                                            | 5    |      |
| Early submission bonus based on the question: "what would have worked on if you were given two extra days?" And the assessment of its feasibility. | The answer was to work on the pipelining by specifically targeting the decoder. Given the way the implementation is elaborated and the programming model adopted, the feasibility of this task is judged as being. The pipelining points are therefore credited. | 5                                                            | 5    |      |
| Total                                                        | 80                                                           | 175                                                          |      |      |
| Total without bonuses                                        | 100                                                          |                                                              |      |      |

Kindly
